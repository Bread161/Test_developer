1.Мила решила отпраздновать свой день рождения в кругу N друзей. Она хочет заказать роллы для всех, поэтому нашла большой сет из T роллов. Про i-го друга она знает, что чтобы насытиться, он должен съесть не менее ai роллов, и что максимальное количество роллов, которое он может съесть, равно bi.
Мила попросила вас посчитать, хватит ли T роллов, чтобы все наелись и при этом не осталось лишних роллов.
Входные данные:
В первой строке даны целые числа N и T. (1≤N≤10**5;0≤T≤10**14)
Во второй и третьей строках даны N целых чисел ai и N целых чисел bi соответственно. (0≤ai≤bi≤10**9)
Выходные данные:
Выведите 'YES', если выбранный сет роллов подходит, или 'NO', если не подходит.



def check_rolls(N, T, a, b):
    total_min =0
    total_max = 0
    
    for i in range(N):
        total_min += a[i]
        total_max += b[i]
    
    if total_min > T or total_max < T:
        return 'NO'
    else:
        return 'YES'
 
# Ввод данных
N, T = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
 
# Проверка и вывод результата
result = check_rolls(N, T, a, b)
print(result)

2.На свой день рождения Мила получила строку S, состоящую из символов '0' и '1'. Но Мила не считает эту строку красивой, поэтому решила ее исправить!
Мила определяет красоту строки следующим образом:
Разобьем строку на максимально длинные подстроки, состоящие из одинаковых символов.
Если все эти подстроки получились одинаковой длины, исходная строка считается красивой, а иначе — некрасивой.
Например, строка '010101' разбивается на подстроки '0', '1', '0', '1', '0', '1' и поэтому является красивой, а строка '000101' разбивается на подстроки '000', '1', '0', '1' и поэтому является некрасивой. Другие примеры красивых строк: '1', '110011', '00001111', '00000000'. Другие примеры некрасивых строк: '011', '010011', '00110100'.
Мила просит вас посчитать, сколько минимум символов нужно изменить в строке S, чтобы сделать ее красивой.
Входные данные:
В единственной строке дана строка S, состоящая из символов '0' и '1'. Длина S лежит в пределах от 1 до 10**5.
Выходные данные:
Выведите минимальное количество изменений в строке S, чтобы она стала красивой.


def min_changes_to_beautiful(s):
    changes = 0
    current_char = s[0]
    current_length = 1
    for i in(1, len(s)):
        if s[i] == current_char:
            current_length +=1
        else:
            current_char = s[i]
            changes += current_length - 1
            current_length = 1
    changes += current_length - 1
    return changes

# Ввод строки S
s = input()
# Вызов функции и вывод результата
print(min_changes_to_beautiful(s))


3.Малыш-робот еще только учится передвигаться самостоятельно, а пока он двигается по заранее написанной разработчиками программе.
Программа состоит из Q последовательных команд вида dir, k, означающих, что робот должен проехать k клеток в направлении dir, где dir— одно из четырех направлений: вниз, вверх, вправо или влево.
Изначально робот находится в позиции (0,0)
. Если после выполнения какой-то команды робот столкнется с препятствием, выведите номер этой команды.
Входные данные :
В первой строке дано целое число N— количество препятствий на поле. (1≤N≤10**5)
В каждой из следующих N строк даны целые числа xi,yi — позиция i-го препятствия. (−10**9≤xi,yi≤10**9)
В следующей строке дано целое число Q— количество команд. (1≤Q≤10**5)
В каждой из следующих Q строк дано описание команд: diri*ki— сделать ki  шагов в направлении diri, где diri является символом 'U', 'D', 'R' или 'L', означающий движение робота вверх, вниз, вправо или влево соответственно. (1≤ki≤10**4)
Выходные данные:
Выведите 'Complete', если робот выполнит всю программу, не столкнувшись с препятствиями. Иначе выведите 'Stop T', где T— номер первой команды, во время выполнения которой робот столкнется с препятствием. (1≤T≤Q)


N = int(input())
obstacles = set()
for _ in range(N):
    x, y = map(int, input().split())
    obstacles.add((x, y))
# Инициализация начальной позиции робота
x, y = 0, 0
# Функция для обновления позиции робота
def move(direction, steps, x, y):
    if direction == 'U':
        return x, y + steps
    elif direction == 'D':
        return x, y - steps
    elif direction == 'R':
        return x + steps, y
    elif direction == 'L':
        return x - steps, y
# Считывание и выполнение команд
Q = int(input())
for command_number in range(1, Q + 1):
    dir, k = input().split()
    k = int(k)
    for step in range(1, k + 1):
        next_x, next_y = move(dir, 1, x, y)  # Перемещаемся на 1 шаг в заданном направлении
        if (next_x, next_y) in obstacles:
            print(f'Stop {command_number}')
            exit(0)
        x, y = next_x, next_y  # Обновляем текущую позицию робота
print('Complete')
