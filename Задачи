1.Мила решила отпраздновать свой день рождения в кругу N друзей. Она хочет заказать роллы для всех, поэтому нашла большой сет из T роллов. Про i-го друга она знает, что чтобы насытиться, он должен съесть не менее ai роллов, и что максимальное количество роллов, которое он может съесть, равно bi.
Мила попросила вас посчитать, хватит ли T роллов, чтобы все наелись и при этом не осталось лишних роллов.
Входные данные:
В первой строке даны целые числа N и T. (1≤N≤10**5;0≤T≤10**14)
Во второй и третьей строках даны N целых чисел ai и N целых чисел bi соответственно. (0≤ai≤bi≤10**9)
Выходные данные:
Выведите 'YES', если выбранный сет роллов подходит, или 'NO', если не подходит.



def check_rolls(N, T, a, b):
    total_min =0
    total_max = 0
    
    for i in range(N):
        total_min += a[i]
        total_max += b[i]
    
    if total_min > T or total_max < T:
        return 'NO'
    else:
        return 'YES'
 
# Ввод данных
N, T = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))
 
# Проверка и вывод результата
result = check_rolls(N, T, a, b)
print(result)

2.На свой день рождения Мила получила строку S, состоящую из символов '0' и '1'. Но Мила не считает эту строку красивой, поэтому решила ее исправить!
Мила определяет красоту строки следующим образом:
Разобьем строку на максимально длинные подстроки, состоящие из одинаковых символов.
Если все эти подстроки получились одинаковой длины, исходная строка считается красивой, а иначе — некрасивой.
Например, строка '010101' разбивается на подстроки '0', '1', '0', '1', '0', '1' и поэтому является красивой, а строка '000101' разбивается на подстроки '000', '1', '0', '1' и поэтому является некрасивой. Другие примеры красивых строк: '1', '110011', '00001111', '00000000'. Другие примеры некрасивых строк: '011', '010011', '00110100'.
Мила просит вас посчитать, сколько минимум символов нужно изменить в строке S, чтобы сделать ее красивой.
Входные данные:
В единственной строке дана строка S, состоящая из символов '0' и '1'. Длина S лежит в пределах от 1 до 10**5.
Выходные данные:
Выведите минимальное количество изменений в строке S, чтобы она стала красивой.


def min_changes_to_beautiful(s):
    changes = 0
    current_char = s[0]
    current_length = 1
    for i in(1, len(s)):
        if s[i] == current_char:
            current_length +=1
        else:
            current_char = s[i]
            changes += current_length - 1
            current_length = 1
    changes += current_length - 1
    return changes

# Ввод строки S
s = input()
# Вызов функции и вывод результата
print(min_changes_to_beautiful(s))


3.Малыш-робот еще только учится передвигаться самостоятельно, а пока он двигается по заранее написанной разработчиками программе.
Программа состоит из Q последовательных команд вида dir, k, означающих, что робот должен проехать k клеток в направлении dir, где dir— одно из четырех направлений: вниз, вверх, вправо или влево.
Изначально робот находится в позиции (0,0)
. Если после выполнения какой-то команды робот столкнется с препятствием, выведите номер этой команды.
Входные данные :
В первой строке дано целое число N— количество препятствий на поле. (1≤N≤10**5)
В каждой из следующих N строк даны целые числа xi,yi — позиция i-го препятствия. (−10**9≤xi,yi≤10**9)
В следующей строке дано целое число Q— количество команд. (1≤Q≤10**5)
В каждой из следующих Q строк дано описание команд: diri*ki— сделать ki  шагов в направлении diri, где diri является символом 'U', 'D', 'R' или 'L', означающий движение робота вверх, вниз, вправо или влево соответственно. (1≤ki≤10**4)
Выходные данные:
Выведите 'Complete', если робот выполнит всю программу, не столкнувшись с препятствиями. Иначе выведите 'Stop T', где T— номер первой команды, во время выполнения которой робот столкнется с препятствием. (1≤T≤Q)


N = int(input())
obstacles = set()
for _ in range(N):
    x, y = map(int, input().split())
    obstacles.add((x, y))
# Инициализация начальной позиции робота
x, y = 0, 0
# Функция для обновления позиции робота
def move(direction, steps, x, y):
    if direction == 'U':
        return x, y + steps
    elif direction == 'D':
        return x, y - steps
    elif direction == 'R':
        return x + steps, y
    elif direction == 'L':
        return x - steps, y
# Считывание и выполнение команд
Q = int(input())
for command_number in range(1, Q + 1):
    dir, k = input().split()
    k = int(k)
    for step in range(1, k + 1):
        next_x, next_y = move(dir, 1, x, y)  # Перемещаемся на 1 шаг в заданном направлении
        if (next_x, next_y) in obstacles:
            print(f'Stop {command_number}')
            exit(0)
        x, y = next_x, next_y  # Обновляем текущую позицию робота
print('Complete')


4.Мила учится складывать числа с... подстроками!  А точнее она Q
 раз последовательно выполняет следующие операции: выбирает подотрезок с li-го по ri-й символ исходной строки S
 и ко всем символам прибавляет число xi.

Прибавление числа x к символу c эквивалентно прибавлению к нему единицы x раз. Прибавление единицы к символу c выполняется по следующим правилам:

Если символ c — символ нижнего регистра (от 'a' до 'z'), то он меняет свой регистр на верхний;
Если символ c — символ верхнего регистра (от 'A' до 'Z'), то он становится следующим по алфавиту символом в нижнем регистре;
Если символ c равен 'Z', то он становится символом 'a'.
Но Мила поняла, что операций слишком много и сама с этой задачей она не справится, поэтому просит вас помочь вычислить строку, которая получится после выполнения всех операций.

Входные данные:
В первой строке дана строка S, состоящая из латинских букв в нижнем и верхнем регистре. (1≤|S|≤10**5; здесь и далее |S| обозначает длину строки S)
Во второй строке дано целое число Q. (1≤Q≤10**5)
В i-й из следующих Q строк даны целые числа li, riи xi. (1≤li≤ri≤|S|; 1≤xi≤10**5)

Выходные данные:
Выведите строку, которая получится после выполнения всех операций.


# Функция для применения правил прибавления числа к символу
def update_char(c, x):
    if 'a' <= c <= 'z':
        return chr(((ord(c) - ord('a') + x) % 26) + ord('a'))
    elif 'A' <= c <= 'Z':
        return chr(((ord(c) - ord('A') + x) % 26) + ord('A' if c != 'Z' else 'a')

# Считываем входные данные
S = input()
Q = int(input())

# Применяем операции к строке S
for _ in range(Q):
    li, ri, xi = map(int, input().split())
    for i in range(li-1, ri):
        S = S[:i] + update_char(S[i], xi) + S[i+1:]

# Выводим получившуюся строку
print(S)
